<!doctype html>
<html>
<head>
    <title>My fancy game</title>
</head>
<body>
    <div id="SplashScreen" style="border:1px solid #000; width: 1000px; height: 600px; ">
        <div align="center" style = "margin-top:100px; margin-right: 100px; margin-left: 100px">
            <h1>My Little Platformer</h1>
            <h3>Get ready for some spectacular action that will blow your mind! Get ready for some spectacular action that will blow your mind! Get ready for some spectacular action that will blow your mind!
            Get ready for some spectacular action that will blow your mind! Get ready for some spectacular action that will blow your mind! Get ready for some spectacular action that will blow your mind!</h3>
            <input id="StartButton" type="button" value="Start" onclick="startGame()" />
        </div>
    </div>

 <canvas id="canvas" style="border:1px solid #000; display:none"></canvas>
<script>
// All of our JavaScript will go here.


var isStarted = false;
// start game function 
function startGame() {
    isStarted = true;
    startTime = new Date().getTime();
    document.getElementById("SplashScreen").style.display = "none";
    document.getElementById("canvas").style.display = "block";
}
(function() {
    var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
    window.requestAnimationFrame = requestAnimationFrame;
})();
var canvas = document.getElementById("canvas"),
    ctx = canvas.getContext("2d"),
    width = 1000,
    height = 600,
    player = {
      x : width/2,
      y : height - 25,
      width : 5,
      height : 5,
      speed: 3,
      velX: 0,
      velY: 0,
      jumping:false,
      grounded: false,
      projectileTimer: Date.now(),
      shootDelay: 200
    },
    keys = [],
    friction = 0.80,
    gravity = 0.3,
    projectiles = [];
canvas.width = width;
canvas.height = height;

var gameWidth = 800;

var monsters = [];
var goodThings = [];
var exit;

var score = 100;
var startTime;
var givenTime = 100;
var elapsedTime, remainingTime;

// level handling
var isGameOver = false;
var isNextLevel = false;

var facing = "E";
// arbitrary counter
var count = 0;
var  currX, currY;

// for platform creation
var boxes = []

var PATH_CHAR = "sprite_sheet2.png";

var CHAR_WIDTH = 24,
    CHAR_HEIGHT = 32,
    IMAGE_START_EAST_Y = 32,
    IMAGE_START_WEST_Y = 96,
    SPRITE_WIDTH = 72;

var TEXT_PRELOADING = "Loading ...", 
    TEXT_PRELOADING_X = 200, 
    TEXT_PRELOADING_Y = 200;

var charImage = new Image();
// charImage.ready = false;
// charImage.onload = setAssetReady;
charImage.src = PATH_CHAR;

// function setAssetReady()
// {
//     this.ready = true;
// }


// ctx.fillStyle = "grey";
// ctx.fillRect(0,0,canvas.width,canvas.height);
// ctx.fillStyle = "#000";
// ctx.fillText(TEXT_PRELOADING, TEXT_PRELOADING_X, TEXT_PRELOADING_Y);
// var preloader = requestAnimationFrame(preloading);

// function preloading()
// {   
//     if (charImage.ready && false)
//     {
//         clearInterval(preloader);
        
//         requestAnimationFrame(update); 
//     }
// }

currX = 0;
currY = IMAGE_START_EAST_Y;

var GAME_MAP = new Array(
    "                                        ",
    "                                        ",
    " E                                      ",
    "###                                     ",
    "  #                                     ",
    "  ##   X    G     X             G       ",
    "  ##################################    ",
    "             ##                         ",
    "             ##                       ##",
    "          G  ##  X G                 ###",
    "         ###########                ####",
    "#    #                 ##       ########",
    "#   ##                ######            ",
    "#########          ##########           ",
    "            ##      ##########          ",
    "           #####                        ",
    "         ########                 G  ###",
    "    ######     ##                #######",
    "##              ###   ###               ",
    "###               #   #######           ",
    "######    G       #   #########      X  ",
    "#####     #                        #####",
    "        ####   X                  ######",
    "       #############             #######",
    "      #####             G  ##   ######  ",
    " G   ###                ####            ",
    "##                    ####              ",
    "###           # #                       ",
    "####   #  X  ######   G  X     X   ##   ",
    "########################################"
    )
var y,x;
for(y=0; y<GAME_MAP.length; y++) {
    var start = null, end = null;

    for(x=0; x<GAME_MAP[y].length; x++) {
        if(start==null && GAME_MAP[y].charAt(x) == '#') {
            start = x;
        }
        if (start != null && GAME_MAP[y].charAt(x) == ' ') {
            end = x - 1;
        }
        if (start != null && x==GAME_MAP[y].length -1) {
            end = x;
        }
        if (start != null && end != null) {
            boxes.push({
                x: start * 20,
                y: y*20,
                width: (end-start+1)*20,
                height: 20
            });
            start = end = null;
        }
        if (GAME_MAP[y].charAt(x) == 'X') {
            monsters.push({
                x: x*20,
                y: y*20,
                width: 20,
                height: 20,
                direction: "E",
                velX: Math.random(),
                leftBoundary: x*20-30,
                rightBoundary: x*20+30
            });
        }

        if(GAME_MAP[y].charAt(x) == 'G') {
            goodThings.push({
                x: x*20,
                y: y*20,
                width: 20,
                height: 20
            });
        }

        if(GAME_MAP[y].charAt(x) == 'E') {
            exit = {
                x: x*20,
                y: y*20,
                width: 20,
                height: 20
            };
        }
    }
}

// game frame
boxes.push({
    x: 0,
    y: 0,
    width: 10,
    height: height
});
boxes.push({
    x: 0,
    y: height - 2,
    width: gameWidth,
    height: 50
});
boxes.push({
    x: gameWidth - 10,
    y: 0,
    width: 50,
    height: height
});


var monster_direction = "E";


function update() {
    console.log("is started: " + isStarted);
    if(isStarted === true) {
        count++;

        executeCommands();

        // update values
        updateProjectiles();
        updateSpriteSheetCoordinates();
        updatePlayerVelocity();
        updatePlayerCoordinates();
        updateMonstersCoordinates();

        clearCanvas();

        // draw objects
        drawProjectiles();
        drawPlayer();
        drawPlatforms();
        drawMonster();
        drawGoodThings();
        drawGUI();
        drawExit();
        // if(monster_direction=="E") {
        //     item.x += 3;
        // } else {
        //     item.x -= 3;
        // }

        // if(item.x > width) {
        //     monster_direction = "W";
        // }
        // if(item.x < 0) {
        //     monster_direction = "E";
        // }


        // handle collision    
        handlePlayerMonsterCollision();
        handleProjectileMonsterCollision();
        handleProjectilePlatformCollision();
        handlePlayerGoodThingCollision();
        handlePlayerExitCollision();

        
    }
    requestAnimationFrame(update);
}

function handleNextLevel() {
    if(isNextLevel == true) {
        // notify player that he finished the current level
        // reposition char at origin
        // update score + remaining secs
        // update GUI with current level number
        // update GUI with new timer
    }
}

function handleGameOver() {
    if(isGameOver == true) {
        // draw a translucent screen
        // show high score table
        // show start again? button

    }
}

function drawExit() {
    if(goodThings.length == 0 ) {
        ctx.fillStyle = "gold";
        ctx.fillRect(exit.x, exit.y, exit.width, exit.height);
    }
}

function drawGUI() {
    ctx.font="20px Arial";
    ctx.fillStyle = "black";
    ctx.fillText("Score:",gameWidth+80,width/2-100);
    ctx.strokeRect(gameWidth+60,width/2-90, 100, 30);
    if(score<10) {
        ctx.fillText(score,gameWidth+100,width/2-70);
    } else if (score < 1000) {
        ctx.fillText(score,gameWidth+95,width/2-70);
    } else {
        ctx.fillText(score,gameWidth+90,width/2-70);
    }
    ctx.fillText("Time:",gameWidth+80,width/2-250);
    ctx.fillStyle = "black";
    ctx.strokeRect(gameWidth+60,width/2-240, 100, 30);



    elapsedTime = parseInt((new Date().getTime()-startTime)/1000, 10);
    remainingTime = givenTime - elapsedTime;
    if (remainingTime >= 0 ) {
        // hack for smooth linear transition of RGB values from green to red
        var percent = 1 - remainingTime/givenTime;
        var R = Math.round((255 * 100*percent) / 100);
        var G = Math.round((255 * (100 - 100*percent)) / 100) ;
        var B = 0;
        // timer bar
        ctx.fillStyle = "rgb(" + R + "," + G + "," + B + ")";
        ctx.fillRect(gameWidth+60+1, width/2-239, 98*(remainingTime/givenTime), 28);
        // timer text
        ctx.fillStyle = "black";
        ctx.fillText(remainingTime,gameWidth+100,width/2-219);
    }
}

function updateMonstersCoordinates() {
    for (var i=0; i<monsters.length; i++) {
        var monster = monsters[i];
        if(monster.direction=="E") {
            monster.x += monster.velX;
        } else {
            monster.x -= monster.velX;
        }

        if(monster.x > monster.rightBoundary) {
            monster.direction = "W";
        }
        if(monster.x < monster.leftBoundary) {
            monster.direction = "E";
        }
    }
}

function Projectile(x, y, direction, size, color, speed) {
    this.x = x;
    this.y = y;
    this.direction = facing;
    this.size = size;
    this.color = color;
    this.speed = speed;
}

function updateProjectiles() {
    for (var key in projectiles) {
        //console.log("inside update projectiles");
        if(projectiles[key].direction == "E")
            projectiles[key].x += 5; 
        else 
            projectiles[key].x -= 5; 
        if (projectiles[key].x > canvas.width || projectiles[key].x < 0) {
            console.log("removed projectile");
            projectiles.splice(key, 1);
        }
    }
}

function drawSquare(x, y, size, color) {
    // console.log("inside draw square");
    ctx.fillStyle = "red";
    ctx.fillRect(Math.round(x), Math.round(y), size, size);
}
function clearCanvas() {
    ctx.clearRect(0, 0, width, height);
}
function updatePlayerVelocity() {
    player.velX *= friction;
    player.velY += gravity;
}
function handleProjectileMonsterCollision() {
    for (var key in projectiles) {
        for(var i=0; i<monsters.length; i++) {
            var monster = monsters[i];
            if (projectiles[key] == null) {
                console.log("projectile null");
                continue;
            }
            if (
                projectiles[key].x < monster.x + monster.width &&
                projectiles[key].x + 10 > monster.x &&
                projectiles[key].y < monster.y + monster.height &&
                projectiles[key].y + 10 > monster.y
            ) {
                // item.x = Math.random() * canvas.width;
                // item.y = height - 10;
                monsters.splice(i, 1);
                projectiles.splice(key, 1);
                score++;
            }
        }
    }
}

function handleProjectilePlatformCollision() {
    for(var key in projectiles) {
        for(var i=0; i<boxes.length; i++) {
            // var isCollided = colCheck(projectiles[key], boxes[i]);
            if(projectiles[key] == null) continue;
            if (
                projectiles[key].x < boxes[i].x + boxes[i].width &&
                projectiles[key].x + 10 > boxes[i].x &&
                projectiles[key].y < boxes[i].y + boxes[i].height &&
                projectiles[key].y + 10 > boxes[i].y
            ) {
                projectiles.splice(key, 1);
            }
        }
    }
}

function handlePlayerMonsterCollision() {
    // handling collision with monster
    for(var i=0; i<monsters.length; i++) {
        var monster = monsters[i];
        if (
            player.x < monster.x + monster.width &&
            player.x + monster.width > monster.x &&
            player.y < monster.y + monster.height &&
            player.y + player.height > monster.y
        ) {
            // item.x = Math.random() * canvas.width;
            // item.y = height - 10;
            console.log("you are dead");
        }
    }
}

function handlePlayerGoodThingCollision() {
    // handling collision with monster
    for(var i=0; i<goodThings.length; i++) {
        var g = goodThings[i];
        if (
            player.x < g.x + g.width &&
            player.x + g.width > g.x &&
            player.y < g.y + g.height &&
            player.y + player.height >g.y
        ) {
            // item.x = Math.random() * canvas.width;
            // item.y = height - 10;
            goodThings.splice(i, 1);
        }
    }
}

function handlePlayerExitCollision() {
    if (
        player.x < exit.x + exit.width &&
        player.x + exit.width > exit.x &&
        player.y < exit.y + exit.height &&
        player.y + player.height >exit.y &&
        goodThings.length == 0
    ) {
        // item.x = Math.random() * canvas.width;
        // item.y = height - 10;
        isNextLevel = true;
        console.log("you won this level");
    }
}


function drawGoodThings() {
    for(var i=0; i<goodThings.length; i++) {
        var g = goodThings[i];
        ctx.fillStyle = "green";
        ctx.fillRect(g.x, g.y, g.width, g.height);
    }
}

function drawMonster() {

    for(var i=0; i<monsters.length; i++) {
        var monster = monsters[i];
        ctx.fillStyle = "red";
        ctx.fillRect(monster.x, monster.y, monster.width, monster.height);
    }
}
function updatePlayerCoordinates() {
    if(player.grounded){
         player.velY = 0;
    }
    
    player.x += player.velX;
    player.y += player.velY;
}
function drawPlatforms() {
    ctx.fillStyle = "black";
    ctx.beginPath();
    
    player.grounded = false;
    for (var i = 0; i < boxes.length; i++) {
        ctx.rect(boxes[i].x, boxes[i].y, boxes[i].width, boxes[i].height);
        
        var dir = colCheck(player, boxes[i]);

        if (dir === "l" || dir === "r") {
            player.velX = 0;
            player.jumping = false;
        } else if (dir === "b") {
            player.grounded = true;
            player.jumping = false;
        } else if (dir === "t") {
            player.velY *= -1;
        }

    }
    ctx.fill();
}
function drawPlayer() {
    // draw a small red box, which will eventually become our player.
    // ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
    // ctx.fillRect(player.x, player.y, player.width, player.height);
    ctx.drawImage(charImage,currX,currY, CHAR_WIDTH,CHAR_HEIGHT,
                    player.x-10,player.y-23,CHAR_WIDTH,CHAR_HEIGHT);
}
function drawProjectiles() {
    for (var key in projectiles) {
        drawSquare(projectiles[key].x, projectiles[key].y, projectiles[key].size, projectiles[key].color);
    }
}
function updateSpriteSheetCoordinates() {
    if(facing=="E") {
        currY = IMAGE_START_EAST_Y;
    } else {
        currY = IMAGE_START_WEST_Y;
    }
    if (currX >= SPRITE_WIDTH) {
        currX = 0;
    }
}
function executeCommands() {
    if (keys[38] || keys[87]) {
        // up arrow or space
        if (!player.jumping && player.grounded) {
            player.jumping = true;
            player.grounded = false;
            player.velY = -player.speed * 2;
        }
    }
    if (keys[39] || keys[68]) {
        // right arrow
        if (player.velX < player.speed) {
            player.velX++;
            if (count%2==0)
                currX += CHAR_WIDTH;
            facing = "E";
        }
    }
    if (keys[37] || keys[65]) {
        // left arrow
        if (player.velX > -player.speed) {
            player.velX--;
            if (count%2==0)
                currX += CHAR_WIDTH;
            facing = "W";
        }
    }
    // button z
    // TODO change to spacebar
    if(keys[32]) {
        if(Date.now() - player.projectileTimer > player.shootDelay) {
            projectiles.push(
                new Projectile(
                    player.x + player.width/2,
                    player.y-10,
                    facing,
                    10,
                    '#0f0',
                    1000
                    )
                );
        }
        player.projectileTimer = Date.now();
    }
}
function colCheck(shapeA, shapeB) {
    // get the vectors to check against
    var vX = (shapeA.x + (shapeA.width / 2)) - (shapeB.x + (shapeB.width / 2)),
        vY = (shapeA.y + (shapeA.height / 2)) - (shapeB.y + (shapeB.height / 2)),
        // add the half widths and half heights of the objects
        hWidths = (shapeA.width / 2) + (shapeB.width / 2),
        hHeights = (shapeA.height / 2) + (shapeB.height / 2),
        colDir = null;

    // if the x and y vector are less than the half width or half height, they we must be inside the object, causing a collision
    if (Math.abs(vX) < hWidths && Math.abs(vY) < hHeights) {
        // figures out on which side we are colliding (top, bottom, left, or right)
        var oX = hWidths - Math.abs(vX),
            oY = hHeights - Math.abs(vY);
        if (oX >= oY) {
            if (vY > 0) {
                colDir = "t";
                shapeA.y += oY;
            } else {
                colDir = "b";
                shapeA.y -= oY;
            }
        } else {
            if (vX > 0) {
                colDir = "l";
                shapeA.x += oX;
            } else {
                colDir = "r";
                shapeA.x -= oX;
            }
        }
    }
    return colDir;
}


window.addEventListener("load", function(){
  update();
});

document.body.addEventListener("keydown", function(e) {
    keys[e.keyCode] = true;
});
 
document.body.addEventListener("keyup", function(e) {
    keys[e.keyCode] = false;
});
</script>
</body>
</html>