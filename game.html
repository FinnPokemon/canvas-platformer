<!doctype html>
<html>
<head>
    <title>My fancy game</title>
</head>
<body>
    <div id="SplashScreen" style="border:1px solid #000; width: 1000px; height: 600px; ">
        <div align="center" style = "margin-top:100px; margin-right: 100px; margin-left: 100px">
            <h1>My Little Platformer</h1>
            <h3>Get ready for some spectacular action that will blow your mind! Get ready for some spectacular action that will blow your mind! Get ready for some spectacular action that will blow your mind!
            Get ready for some spectacular action that will blow your mind! Get ready for some spectacular action that will blow your mind! Get ready for some spectacular action that will blow your mind!</h3>
            <input type="text" id="playerName" placeholder="Enter your name here" onkeyup="enableStartButton()" />
            <input disabled id="StartButton" type="button" value="Start" onclick="startGame()" />
        </div>
    </div>

<canvas id="canvas" style="border:1px solid #000; display:none"></canvas>
<div>
    <input id="RestartButton" type="button" value = "Play again!" onclick="restartGame()" style="position: absolute; left:370px; top:500px;display:none" />
</div>
<script>
// All of our JavaScript will go here.
function enableStartButton() {
    document.getElementById("StartButton").disabled = false;
}
function restartGame() {
    document.getElementById("RestartButton").style.display = "none";
    givenTime = 100;
    startTime = new Date().getTime();
    isGameOver = false;
    isFirstTime = true;
    currentLevel = 1;
    monsters = [];
    goodThings = [];
    keys = [];
    initialiseMap();
    player.x = playerInitX;
    player.y = playerInitY;
    player.bullets = 8;
    player.velX = 0;
    player.velY = 0;
    player.score = initScore;
}

var isStarted = false;
// start game function 
function startGame() {
    player.name = document.getElementById("playerName").value;
    isStarted = true;
    startTime = new Date().getTime();
    initialiseMap();
    document.getElementById("SplashScreen").style.display = "none";
    document.getElementById("canvas").style.display = "block";
}
(function() {
    var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
    window.requestAnimationFrame = requestAnimationFrame;
})();
var canvas = document.getElementById("canvas"),
    ctx = canvas.getContext("2d"),
    width = 1000,
    height = 600,
    player = {
      x : width/2-90,
      y : height - 25,
      width : 5,
      height : 5,
      speed: 3,
      velX: 0,
      velY: 0,
      jumping:false,
      grounded: false,
      projectileTimer: Date.now(),
      shootDelay: 200,
      name: "Alex",
      score: 0,
      cheatmode: false,
      bullets: 8
    },
    keys = [],
    friction = 0.80,
    gravity = 0.3,
    projectiles = [];
canvas.width = width;
canvas.height = height;

var playerInitX = width/2-90;
var playerInitY = height-25;
var initScore = 0;

var gameWidth = 800;

var monsters = [];
var goodThings = [];
var exit;

var score = 100;
var startTime;
var givenTime = 100;
var elapsedTime, remainingTime;

// level handling
var isGameOver = false;
var isNextLevel = false;
var isFirstTime = true;
var scoreTable;
var currentLevel = 1;

var facing = "E";
// arbitrary counter
var count = 0;
var  currX, currY;

// for platform creation
var boxes = []

var PATH_CHAR = "sprite_sheet2.png";

var CHAR_WIDTH = 24,
    CHAR_HEIGHT = 32,
    IMAGE_START_EAST_Y = 32,
    IMAGE_START_WEST_Y = 96,
    SPRITE_WIDTH = 72;

var TEXT_PRELOADING = "Loading ...", 
    TEXT_PRELOADING_X = 200, 
    TEXT_PRELOADING_Y = 200;

var charImage = new Image();
// charImage.ready = false;
// charImage.onload = setAssetReady;
charImage.src = PATH_CHAR;

var monsterImage = new Image();
monsterImage.src = "monster_sprite2.png";
// function setAssetReady()
// {
//     this.ready = true;
// }


// ctx.fillStyle = "grey";
// ctx.fillRect(0,0,canvas.width,canvas.height);
// ctx.fillStyle = "#000";
// ctx.fillText(TEXT_PRELOADING, TEXT_PRELOADING_X, TEXT_PRELOADING_Y);
// var preloader = requestAnimationFrame(preloading);

// function preloading()
// {   
//     if (charImage.ready && false)
//     {
//         clearInterval(preloader);
        
//         requestAnimationFrame(update); 
//     }
// }

currX = 0;
currY = IMAGE_START_EAST_Y;

var GAME_MAP = new Array(
    "                                        ",
    "                                        ",
    " E                                      ",
    "###                                     ",
    "  #                                     ",
    "  ##   X    G     X             G       ",
    "  ##################################    ",
    "             ##                         ",
    "             ##                       ##",
    "          G  ##  X G                 ###",
    "         ###########                ####",
    "#    #                 ##       ########",
    "#   ##                ######            ",
    "#########          ##########           ",
    "            ##      ##########          ",
    "           #####                        ",
    "         ########                 G  ###",
    "    ######     ##                #######",
    "##              ###   ###               ",
    "###               #   #######           ",
    "######    G       #   #########      X  ",
    "#####     #                        #####",
    "        ####   X                  ######",
    "       #############             #######",
    "      #####             G  ##   ######  ",
    " G   ###                ####            ",
    "##                    ####              ",
    "###           # #                       ",
    "####   #  X  ######   G  X     X   ##   ",
    "########################################"
    )
function initialiseMap() {
    var y,x;
    for(y=0; y<GAME_MAP.length; y++) {
        var start = null, end = null;

        for(x=0; x<GAME_MAP[y].length; x++) {
            if(start==null && GAME_MAP[y].charAt(x) == '#') {
                start = x;
            }
            if (start != null && GAME_MAP[y].charAt(x) == ' ') {
                end = x - 1;
            }
            if (start != null && x==GAME_MAP[y].length -1) {
                end = x;
            }
            if (start != null && end != null) {
                boxes.push({
                    x: start * 20,
                    y: y*20,
                    width: (end-start+1)*20,
                    height: 20
                });
                start = end = null;
            }
            if (GAME_MAP[y].charAt(x) == 'X') {
                monsters.push({
                    x: x*20,
                    y: y*20,
                    width: 20,
                    height: 20,
                    direction: "E",
                    velX: Math.random(),
                    leftBoundary: x*20-30,
                    rightBoundary: x*20+30,
                    currSpriteX: 0,
                    currSpriteY: IMAGE_START_EAST_Y
                });
            }

            if(GAME_MAP[y].charAt(x) == 'G') {
                goodThings.push({
                    x: x*20,
                    y: y*20,
                    width: 20,
                    height: 20
                });
            }

            if(GAME_MAP[y].charAt(x) == 'E') {
                exit = {
                    x: x*20,
                    y: y*20,
                    width: 20,
                    height: 20
                };
            }
        }
    }
}

function spawnMonsters() {
    var y,x;
    for(y=0; y<GAME_MAP.length; y++) {
        var start = null, end = null;

        for(x=0; x<GAME_MAP[y].length; x++) {
            if (GAME_MAP[y].charAt(x) == 'X') {
                monsters.push({
                    x: x*20,
                    y: y*20,
                    width: 20,
                    height: 20,
                    direction: "E",
                    velX: Math.random(),
                    leftBoundary: x*20-30,
                    rightBoundary: x*20+30,
                    currSpriteX: 0,
                    currSpriteY: IMAGE_START_EAST_Y
                });
            }
        }
    }
}

// game frame
boxes.push({
    x: 0,
    y: 0,
    width: 10,
    height: height
});
boxes.push({
    x: 0,
    y: height - 2,
    width: gameWidth,
    height: 50
});
boxes.push({
    x: gameWidth - 10,
    y: 0,
    width: 50,
    height: height
});


var monster_direction = "E";


function update() {
    // console.log("is started: " + isStarted);
    if(isStarted === true) {
        count++;
        if(!isGameOver == true) {
            executeCommands();
        }

        // update values
        updateProjectiles();
        updateSpriteSheetCoordinates();
        updatePlayerVelocity();
        updatePlayerCoordinates();
        updateMonstersCoordinates();

        clearCanvas();

        // draw objects
        drawProjectiles();
        drawPlayer();
        drawPlatforms();
        drawMonster();
        drawGoodThings();
        drawGUI();
        drawExit();
        drawPlayerName();
        // if(monster_direction=="E") {
        //     item.x += 3;
        // } else {
        //     item.x -= 3;
        // }

        // if(item.x > width) {
        //     monster_direction = "W";
        // }
        // if(item.x < 0) {
        //     monster_direction = "E";
        // }


        // handle collision    
        handlePlayerMonsterCollision();
        handleProjectileMonsterCollision();
        handleProjectilePlatformCollision();
        handlePlayerGoodThingCollision();
        handlePlayerExitCollision();
        handleNextLevel();

        handleGameOver();

        
    }
    requestAnimationFrame(update);
}
function drawPlayerName() {
    ctx.font = "10px Arial";
    ctx.fillStyle = "black";
    var len = player.name.length; 
    ctx.fillText(player.name, player.x-len*2, player.y-25);
}
function ScoreRecord(name, score) {
    this.name = name;
    this.score = score;
}

function getHighScoreTable() {
    var scoreTable = new Array();
    // console.log("doc cookie: " + document.cookie);
    for(var i=0; i<10; i++) {
        var cookieName = "player" + i;
        // console.log("player i: " + cookieName);
        // var scoreRecord = getCookie(cookieName);
        var scoreRecord = localStorage.getItem(cookieName);
        if(scoreRecord == null) {
            // console.log("score record is null");
            break;
        } 
        var name = scoreRecord.split("~")[0];
        var score = scoreRecord.split("~")[1];
        // console.log("name: " + name);
        scoreTable.push(new ScoreRecord(name, score));
    }
    return scoreTable;
}
//
// This function stores the high score table to the cookies
//
function setHighScoreTable(table) {
    for (var i = 0; i < 10; i++) {
        // If i is more than the length of the high score table exit
        // from the for loop
        if (i >= table.length) break;

        // Contruct the cookie name
        var cookieName = "player" + i;
        var name = table[i].name;
        var score = table[i].score;

        // Store the ith record as a cookie using the cookie name
        localStorage.setItem(cookieName, name +"~"+score);
    }
}

function addHighScore(name, score) {
    var table = getHighScoreTable();
    console.log("table length: " + table.length);

    for(var i=0; i<table.length; i++) {
        if(score >= table[i].score) {
            var record = new ScoreRecord(name, score);
            console.log("splicing table");
            table.splice(i, 0, record);
            return table;
        }
    }
    if (table.length <= 10) {
        table.push(new ScoreRecord(name, score));
    }
    return table;
}
function setCookie(name, value, expires, path, domain, secure) { 
     var curCookie = name + "=" + escape(value) + 
     ((expires) ? "; expires=" + expires.toGMTString() : "") + 
     ((path) ? "; path=" + path : "") + 
     ((domain) ? "; domain=" + domain : "") + 
     ((secure) ? "; secure" : ""); 
     // console.log("curCookie: " + curCookie);
     document.cookie = curCookie; 
     // console.log("document cookie: " + document.cookie);
} 


function getCookie(name) { 
     var dc = document.cookie; 
     var prefix = name + "="; 
     var begin = dc.indexOf("; " + prefix); 
     if (begin == -1) { 
        begin = dc.indexOf(prefix); 
     if (begin != 0) return null; 
     } else begin += 2; 
     var end = document.cookie.indexOf(";", begin); 
     if (end == -1) end = dc.length; 
     return unescape(dc.substring(begin + prefix.length, end)); 
}

function handleNextLevel() {
    if(isNextLevel == true) {
        // notify player that he finished the current level
        alert("you owned this lvl :)");
        // reposition char at origin
        player.x = playerInitX;
        player.y = playerInitY;
        player.velX = 0;
        player.velY = 0;
        player.bullets = 8;
        keys = [];
        // update score + remaining secs
        player.score += remainingTime;
        // update GUI with current level number
        currentLevel++;
        // update GUI with new timer + remaining sec
        givenTime = 100 + remainingTime;
        startTime = new Date().getTime();
        // populate map with more monsters
        monsters = [];
        goodThings = [];
        initialiseMap();
        for(var i=1; i<currentLevel; i++) {
            spawnMonsters();
        }
        isNextLevel = false;
    }
}

function handleGameOver() {
    if(isGameOver == true) { 
        if(isFirstTime == true) {
            var table = addHighScore(player.name, player.score);
            setHighScoreTable(table);
        }
        drawGameOverScreen();
        document.getElementById("RestartButton").style.display = "block";
        isFirstTime = false;
    }
}
function drawGameOverScreen() {
    ctx.fillStyle = "rgba(0, 0, 200, 0.7)";
    ctx.fillRect(50, 50, gameWidth-100, height-100);
    ctx.fillStyle = "white";
    ctx.font = "100px Arial";
    ctx.fillText("Game Over", 150, 150);

    var table = getHighScoreTable();
    ctx.fillStyle = "white";
    ctx.fillRect(80, 170, gameWidth-160, height-300);
    ctx.font = "30px Arial";
    ctx.fillStyle = "black";
    ctx.fillText("High Score", 320, 210);
    ctx.font = "15px Arial";
    for(var i=0; i<table.length; i++) {
        var name = table[i].name;
        var score = table[i].score;
        // console.log("name.length: " + name.length + ", score.length: " + score.length);
        var numSpaces = 35 - name.length - score.length;
        if(numSpaces + name.length + score.length != 35) console.log("not 35");
        var str = name+ whiteSpace(numSpaces) + score;
        if(str.length != 36) console.log("str len: " + str.length);
        ctx.fillText(name, 310, 240+i*20);
        ctx.fillText(score, 310+145, 240+i*20);
        // console.log("string len: " + (name+ whiteSpace(35 - name.length - score.length) + score).length);
    }
}
function whiteSpace(num) {
    var sp = " ";
    for(var i=0; i<num ;i++) {
        sp += " ";
    }
    return sp;
}
function drawExit() {
    if(goodThings.length == 0 ) {
        ctx.fillStyle = "gold";
        ctx.fillRect(exit.x, exit.y, exit.width, exit.height);
    }
}

function drawGUI() {
    ctx.font="15px Arial";
    ctx.fillStyle = "black";
    ctx.fillText("Cheat mode: " + (player.cheatmode ? "On" : "Off"), gameWidth+60, width/2);
    ctx.font="20px Arial";
    ctx.fillStyle = "black";
    ctx.fillText("Level " + currentLevel, gameWidth+80, width/2-300);
    ctx.fillText("Bullets: " + player.bullets, gameWidth+70, width/2-150);
    ctx.fillText("Score:",gameWidth+80,width/2-100);
    ctx.strokeRect(gameWidth+60,width/2-90, 100, 30);
    var score = player.score;
    if(score<10) {
        ctx.fillText(score,gameWidth+100,width/2-70);
    } else if (score < 1000) {
        ctx.fillText(score,gameWidth+95,width/2-70);
    } else {
        ctx.fillText(score,gameWidth+90,width/2-70);
    }
    ctx.fillText("Time:",gameWidth+80,width/2-250);
    ctx.fillStyle = "black";
    ctx.strokeRect(gameWidth+60,width/2-240, 100, 30);



    elapsedTime = parseInt((new Date().getTime()-startTime)/1000, 10);
    remainingTime = givenTime - elapsedTime;
    if (!isGameOver && remainingTime >= 0) {
        // hack for smooth linear transition of RGB values from green to red
        var percent = 1 - remainingTime/givenTime;
        var R = Math.round((255 * 100*percent) / 100);
        var G = Math.round((255 * (100 - 100*percent)) / 100) ;
        var B = 0;
        // timer bar
        ctx.fillStyle = "rgb(" + R + "," + G + "," + B + ")";
        ctx.fillRect(gameWidth+60+1, width/2-239, 98*(remainingTime/givenTime), 28);
        // timer text
        ctx.fillStyle = "black";
        ctx.fillText(remainingTime,gameWidth+100,width/2-219);
    } 
    if(remainingTime <= 0 && player.cheatmode == false) {
        isGameOver = true;
    }
}

function updateMonstersCoordinates() {
    for (var i=0; i<monsters.length; i++) {
        var monster = monsters[i];
        if(monster.direction=="E") {
            monster.x += monster.velX;
        } else {
            monster.x -= monster.velX;
        }

        if(monster.x > monster.rightBoundary) {
            monster.direction = "W";
        }
        if(monster.x < monster.leftBoundary) {
            monster.direction = "E";
        }
        // update sprite sheet coords
        if (count%10==0) monster.currSpriteX += CHAR_WIDTH;
        if(monster.direction=="E") {
            monster.currSpriteY = IMAGE_START_EAST_Y;
        } else {
            monster.currSpriteY = IMAGE_START_WEST_Y;
        }
        if (monster.currSpriteX >= SPRITE_WIDTH) {
            monster.currSpriteX = 0;
        }
    }
}

function Projectile(x, y, direction, size, color, speed) {
    this.x = x;
    this.y = y;
    this.direction = facing;
    this.size = size;
    this.color = color;
    this.speed = speed;
}

function updateProjectiles() {
    for (var key in projectiles) {
        //console.log("inside update projectiles");
        if(projectiles[key].direction == "E")
            projectiles[key].x += 5; 
        else 
            projectiles[key].x -= 5; 
        if (projectiles[key].x > canvas.width || projectiles[key].x < 0) {
            console.log("removed projectile");
            projectiles.splice(key, 1);
        }
    }
}

function drawSquare(x, y, size, color) {
    // console.log("inside draw square");
    ctx.fillStyle = "red";
    ctx.fillRect(Math.round(x), Math.round(y), size, size);
}
function clearCanvas() {
    ctx.clearRect(0, 0, width, height);
}
function updatePlayerVelocity() {
    player.velX *= friction;
    player.velY += gravity;
}
function handleProjectileMonsterCollision() {
    for (var key in projectiles) {
        for(var i=0; i<monsters.length; i++) {
            var monster = monsters[i];
            if (projectiles[key] == null) {
                console.log("projectile null");
                continue;
            }
            if (
                projectiles[key].x < monster.x + monster.width &&
                projectiles[key].x + 10 > monster.x &&
                projectiles[key].y < monster.y + monster.height &&
                projectiles[key].y + 10 > monster.y
            ) {
                // item.x = Math.random() * canvas.width;
                // item.y = height - 10;
                monsters.splice(i, 1);
                projectiles.splice(key, 1);
                player.score++;
            }
        }
    }
}

function handleProjectilePlatformCollision() {
    for(var key in projectiles) {
        for(var i=0; i<boxes.length; i++) {
            // var isCollided = colCheck(projectiles[key], boxes[i]);
            if(projectiles[key] == null) continue;
            if (
                projectiles[key].x < boxes[i].x + boxes[i].width &&
                projectiles[key].x + 10 > boxes[i].x &&
                projectiles[key].y < boxes[i].y + boxes[i].height &&
                projectiles[key].y + 10 > boxes[i].y
            ) {
                projectiles.splice(key, 1);
            }
        }
    }
}

function handlePlayerMonsterCollision() {
    // handling collision with monster
    for(var i=0; i<monsters.length; i++) {
        var monster = monsters[i];
        if (
            player.x < monster.x + monster.width &&
            player.x + monster.width > monster.x &&
            player.y < monster.y + monster.height &&
            player.y + player.height > monster.y &&
            player.cheatmode == false
        ) {
            // item.x = Math.random() * canvas.width;
            // item.y = height - 10;
            isGameOver = true;
            // console.log("you are dead");
        }
    }
}

function handlePlayerGoodThingCollision() {
    // handling collision with monster
    for(var i=0; i<goodThings.length; i++) {
        var g = goodThings[i];
        if (
            player.x < g.x + g.width &&
            player.x + g.width > g.x &&
            player.y < g.y + g.height &&
            player.y + player.height >g.y
        ) {
            // item.x = Math.random() * canvas.width;
            // item.y = height - 10;
            goodThings.splice(i, 1);
            player.score += 10;
        }
    }
}

function handlePlayerExitCollision() {
    if (
        player.x < exit.x + exit.width &&
        player.x + exit.width > exit.x &&
        player.y < exit.y + exit.height &&
        player.y + player.height >exit.y &&
        goodThings.length == 0
    ) {
        // item.x = Math.random() * canvas.width;
        // item.y = height - 10;
        isNextLevel = true;
        console.log("you won this level");
    }
}


function drawGoodThings() {
    for(var i=0; i<goodThings.length; i++) {
        var g = goodThings[i];
        ctx.fillStyle = "green";
        ctx.fillRect(g.x, g.y, g.width, g.height);
    }
}

function drawMonster() {

    for(var i=0; i<monsters.length; i++) {
        var monster = monsters[i];
        // ctx.fillStyle = "red";
        // ctx.fillRect(monster.x, monster.y, monster.width, monster.height);
        ctx.drawImage(monsterImage,monster.currSpriteX,monster.currSpriteY, CHAR_WIDTH,CHAR_HEIGHT,
                    monster.x-10,monster.y-11,CHAR_WIDTH,CHAR_HEIGHT);
    }
}
function updatePlayerCoordinates() {
    if(player.grounded){
         player.velY = 0;
    }
    
    player.x += player.velX;
    player.y += player.velY;
}
function drawPlatforms() {
    ctx.fillStyle = "black";
    ctx.beginPath();
    
    player.grounded = false;
    for (var i = 0; i < boxes.length; i++) {
        ctx.rect(boxes[i].x, boxes[i].y, boxes[i].width, boxes[i].height);
        
        var dir = colCheck(player, boxes[i]);

        if (dir === "l" || dir === "r") {
            player.velX = 0;
            player.jumping = false;
        } else if (dir === "b") {
            player.grounded = true;
            player.jumping = false;
        } else if (dir === "t") {
            player.velY *= -1;
        }

    }
    ctx.fill();
}
function drawPlayer() {
    // draw a small red box, which will eventually become our player.
    // ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
    // ctx.fillRect(player.x, player.y, player.width, player.height);
    if(!isGameOver) {
        ctx.drawImage(charImage,currX,currY, CHAR_WIDTH,CHAR_HEIGHT,
                    player.x-10,player.y-23,CHAR_WIDTH,CHAR_HEIGHT);
    }
}
function drawProjectiles() {
    for (var key in projectiles) {
        drawSquare(projectiles[key].x, projectiles[key].y, projectiles[key].size, projectiles[key].color);
    }
}
function updateSpriteSheetCoordinates() {
    if(facing=="E") {
        currY = IMAGE_START_EAST_Y;
    } else {
        currY = IMAGE_START_WEST_Y;
    }
    if (currX >= SPRITE_WIDTH) {
        currX = 0;
    }
}
function executeCommands() {
    if (keys[38] || keys[87]) {
        // up arrow or space
        if (!player.jumping && player.grounded) {
            player.jumping = true;
            player.grounded = false;
            player.velY = -player.speed * 2;
        }
    }
    if (keys[39] || keys[68]) {
        // right arrow
        if (player.velX < player.speed) {
            player.velX++;
            if (count%2==0)
                currX += CHAR_WIDTH;
            facing = "E";
        }
    }
    if (keys[37] || keys[65]) {
        // left arrow
        if (player.velX > -player.speed) {
            player.velX--;
            if (count%2==0)
                currX += CHAR_WIDTH;
            facing = "W";
        }
    }
    // button z
    // TODO change to spacebar
    if(keys[32]) {
        if(Date.now() - player.projectileTimer > player.shootDelay && (player.bullets > 0 || player.cheatmode == true) ) {
            projectiles.push(
                new Projectile(
                    player.x + player.width/2,
                    player.y-10,
                    facing,
                    10,
                    '#0f0',
                    1000
                    )
                );
            player.bullets = player.bullets > 0 ? player.bullets - 1 : 0;
        }
        player.projectileTimer = Date.now();
    }
    // button c: cheat mode on
    if(keys[67]) {
        player.cheatmode = true;
    }

    // button v: cheat mode off
    if (keys[86]) {
        player.cheatmode = false;
    }
}
function colCheck(shapeA, shapeB) {
    // get the vectors to check against
    var vX = (shapeA.x + (shapeA.width / 2)) - (shapeB.x + (shapeB.width / 2)),
        vY = (shapeA.y + (shapeA.height / 2)) - (shapeB.y + (shapeB.height / 2)),
        // add the half widths and half heights of the objects
        hWidths = (shapeA.width / 2) + (shapeB.width / 2),
        hHeights = (shapeA.height / 2) + (shapeB.height / 2),
        colDir = null;

    // if the x and y vector are less than the half width or half height, they we must be inside the object, causing a collision
    if (Math.abs(vX) < hWidths && Math.abs(vY) < hHeights) {
        // figures out on which side we are colliding (top, bottom, left, or right)
        var oX = hWidths - Math.abs(vX),
            oY = hHeights - Math.abs(vY);
        if (oX >= oY) {
            if (vY > 0) {
                colDir = "t";
                shapeA.y += oY;
            } else {
                colDir = "b";
                shapeA.y -= oY;
            }
        } else {
            if (vX > 0) {
                colDir = "l";
                shapeA.x += oX;
            } else {
                colDir = "r";
                shapeA.x -= oX;
            }
        }
    }
    return colDir;
}


window.addEventListener("load", function(){
  update();
});

document.body.addEventListener("keydown", function(e) {
    keys[e.keyCode] = true;
});
 
document.body.addEventListener("keyup", function(e) {
    keys[e.keyCode] = false;
});
</script>
</body>
</html>